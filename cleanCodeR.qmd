---
title: "Clean Code in R"
format:
  html:
    theme: flatly
    toc: true
execute:
  echo: false
highlight-style: github  # Syntax highlighting (changeable)
css: styles.css
---

One level of abstraction - no nested loops! negation i.e. createTableTitle()

```{r}
source("helpers.R")
```

```{r, eval=FALSE, results='asis'}
makeBadBox('head(mtcars)')
makeGoodBox('head(mtcars)')
makeBetterBox('head(mtcars)')
```

## Intro

Code is clean if it can be understood easily – by everyone on the team - and also future you! Clean code makes it more maintainable and easier to debug. Clean code comes from many iterations of failing and practice. Writing clean code is never perfect the first shot and takes experience to improve! I will share tips and examples I've learned mainly from Robert Martin - AKA "Uncle Bob" and apply them to R programming.

This is not a coding style guide (tidyverse). I've decided to use camelCase for all object names for consistency.

------------------------------------------------------------------------

## Key Takeaways

1.  Follow standard naming conventions of variables and functions.
2.  Keep it simple stupid. Simpler is always better. Reduce complexity as much as possible.
3.  Boy scout rule. Leave the campground cleaner than you found it.

Change one variable name for the better, break up one function that’s a little too large, eliminate one small bit of duplication, clean up one composite if statement.

4.  Always look for the root cause of a problem.

## Naming Conventions

### Use Meaningful Names

Names should reveal the intent. It should tell you why it exists, what it does, and how it is used. If a name requires a comment as to what the code does, then the name does not reveal its intent. Let's say we use `date` - but what date? It could be today's date, or perhaps one's birthday? We also want to describe the type of measure. So what does the date represent? If it's the project date, just change to `projectStartDate.`

```{r, results='asis'}
makeBadBox('FlwRt()
date = "2024-01-01" # date project started')
makeGoodBox('FURate()
startDate = "2024-01-01" # of the project')
makeBetterBox('calcFollowupRate()
projectStartDate = "2024-01-01"')
```

### Choose descriptive and unambiguous names

Be sure names actually represent what the object does. `patientList` should really be a list, because list means something specific to programmers. Dataframes and values should have a noun or noun phrase like `totalOhioPopulation` or `currentShiftList`. Functions should have a verb or a verb phrase and be descriptive. Avoid general verbs:

| Word  | Alternatives                                      |
|-------|---------------------------------------------------|
| send  | deliver, dispatch, announce, distribute, route    |
| find  | search, extract, locate, recover                  |
| start | launch, create, begin, open                       |
| make  | create, set up, build, generate, compose, add new |

### Make meaningful distinction

Names should be used appropriately and consistently. Using `patients` and `person` interchangeably is inconsistent and confusing. Also be as descriptive as possible. Don't use `patientsA` `patientsB` rather describe the differences between the two such as `patientsWithDiabetes` and `patientsWithHypertension`. But don't also have `A1CPatients` since it follows a different naming standard as it doesn't start with *patients*.

xx There are a few names which are meaningful in and of themselves—most are not. Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces. When all else fails, then prefixing the name may be necessary as a last resort.

Imagine that you have variables named `firstName`, `lastName`, `street`, `houseNumber`, `city`, `state`, and `zipcode.` Taken together it’s pretty clear that they form an address. But what if you just saw the `state` variable being used alone in a function? Would you automatically infer that it was part of an address? You can add context by using prefixes: `addrFirstName`, `addrLastName`, `addrState`, and so on. At least readers will understand that these variables are part of a larger structure.

### Use pronounceable names

Use words, like actual words. If I see `flwRate` I'll say flow rate in my head, but this really means Follow-up rate. I'm thinking about translating this word rather than skimming my code - this hinders readable code. Use abbreviations only when it's common in industry.

### Use searchable names.

Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text. ?? One might easily grep for MAX_CLASSES_PER_STUDENT, but the number 7 could be more troublesome. Searches may turn up the digit as part of file names, other constant definitions, and in various expressions where the value is used with different intent.

If using single letter variable, it should only be used with that single line of code.

```{r, results='asis'}
makeBadBox('s = 0
for (i in 1:5) {
  d = i * 4
  e = d / 5
  s = s + e
}')
makeBetterBox('realDaysPerIdealDay = 4
  workDaysPerWeek = 5
  sum = 0
  
  for (i in 1:workDaysPerWeek) {
  realTaskDays = i * realDaysPerIdealDay
  realTaskWeeks = realTaskDays / workDaysPerWeek
  sum = realTaskWeeks + sum
}')
```

Note that `sum`, above, is not a particularly useful name but at least it's searchable. The intentionally named code makes for a longer function, but consider how much easier it will be to find WORK_DAYS_PER_WEEK than to find all the places where 5 was used and filter the list down to just the instances with the intended meaning.

If a longer loop, describe what the loop is iterating over.

```{r, results='asis'}
makeBetterBox('for (shift in shiftList){
# CODE GOES HERE
}')
```

### Pick one word per concept

Pick one word for one abstract concept and stick with it. For instance, it’s confusing to have `fetch`, `retrieve`, and `get` as equivalent methods of different classes. How do you remember which function name goes with which class? Sadly, you often have to remember which company, group, or individual wrote the library or class in order to remember which term was used. Otherwise, you spend an awful lot of time browsing through headers and previous code samples

### Replace magic numbers with named constants.

Do not use numbers. While AADT is an acronym, I believe it's fitting in this context as it is domain knowledge to anyone who uses this code. Further, it adds context to the equation.

```{r, results='asis'}
makeBadBox('MainStAADT = 12081500 / 365')
makeBetterBox('daysPerYear = 365
             MainStAnnualCount = 12081500
MainStAADT = MainStAnnualCount / daysPerYear"')
```

## Understandability tips

1.  Be consistent. If you do something a certain way, do all similar things in the same way.
2.  Use explanatory variables.
3.  Encapsulate boundary conditions. Boundary conditions are hard to keep track of. Put the processing for them in one place.
4.  Prefer dedicated value objects to primitive type.
5.  Avoid logical dependency. Don't write methods which works correctly depending on something else in the same class.
6.  Avoid negative conditionals.

## Functions rules

### Small

Function should be small and tell a story, meaning the name should be clear what the function does. Furthmore, input and output and the guts in between.

### Do one thing / One level of abstraction per function

Let's look at this example and break it down. First, it reads a csv. Then it does some data cleaning and recodes data. It does 3 things. So to prep data, many steps are taken. Statements within a function should have same level of abstraction per function. This can be broken down into multiple small functions.

```{r, echo=FALSE}
prepData <- function(csvName, migCol){
  csv <- read.csv(paste0(csvName,".csv")) |> janitor::clean_names()
  csv |> mutate(NewMig = case_when(
    migCol == 1 ~ "Yes",
    migCol == 0 ~ "NO",
    TRUE ~ NA
  ))
}
```

```{r, echo=FALSE}
prepData <- function(csvName, migCol){
  csv <- readCSV(csvName) |>
    cleanDataCols() |> 
    recodeData(migCol)
}

readCSV <- function(csvName){
  read.csv(paste0(csvName,".csv"))
}

cleanDataCols <- function(csvName){
  df |> janitor::clean_names()
}

# TODO
recodeData <- function(df){
  df |> mutate(
  NewMig = case_when(
    migCol == 1 ~ "Yes",
    migCol == 0 ~ "NO",
    TRUE ~ NA
 ) )
}

```

When functions are broken down like this, we want the script to read from top to bottom. Uncle Bob calls this the *The Stepdown Rule*. The first function should be the top level of abstraction. Followed by the next level of abstraction and so forth. We have `prepDataprepData()` followed by child functions used in this parent function.

### Use descriptive names

Half the battle to achieving that principle is choosing good names for small functions that do one thing. The smaller and more focused a function is, the easier it is to choose a descriptive name. Don’t be afraid to make a name long. A long descriptive name is better than a short enigmatic name. A long descriptive name is better than a long descriptive comment.

pg 152 \###

### Have no side effects

If a function does one thing and intent is clear then there's no side effects. A function should do what it intends to do and also use inputs only for the function. The global state must never be modified.

### Write vectorized function

{purrrr}

```{r}
# Non-vectorized
positive <- numeric(0)
for (i in 1:length(x)) {
  if (x[i] > 0) {
    positive <- c(positive, x[i])
  }
}

# Vectorized
positive <- x[x > 0]
```

### Simple, flexible functions

Take a look at these two functions.

```{r}
makeBetterBox('multiplyTwoValues <- function(df, newColName, one_value, second_value){   df |> dplyr::mutate({{newColName}} := {{one_value}} * {{second_value}}) } ')

makeBetterBox('multiplyTwoValues <- function(one_value, second_value){   one_value * second_value }')
```

The first assumes the input will always be a dataframe, forcing a specific workflow. The second function allows for more simplicity, flexibility, and minimal overhead. Its concise design makes it highly reusable across a wide range of contexts, as it works with any vectorized inputs—scalars, vectors, or matrices—without requiring a data frame or the dplyr package, reducing dependencies and potential performance overhead. This function is faster for standalone operations due to its direct use of R’s native vectorized \* operator. Additionally, its generality allows it to be applied in diverse situations, such as quick calculations or non-data-frame workflows, making it more versatile for users who need a lightweight, pure function that aligns with R’s functional programming principles and delivers efficient, predictable results without the need for data frame-specific operations.

❌ Hard to reuse: Cannot be used for standalone calculations. ❌ Not modular: If you need the multiplication outside dplyr, you’d have to write another function.

✅ Fully reusable: multiplyTwoValues(a, b) works anywhere (in mutate(), map(), or standalone). ✅ Modular: The logic is separate from the mutate() call. ✅ More flexible: You can use it in non-dplyr contexts, such as loops, purrr functions, or even inside ggplot calculations.

## Comments rules

### Explain yourself through code

There are times when comments are necessary or beneficial. Like to describe the decision the coder had to make or to describe a regular expression. In this example, it may not be obvious that xx

```{r}
makeBetterBox('multiplyTwoValues <- function(one_value, second_value){
  one_value * second_value
}')
```

Do note, that over time a comment get outdated and be simply incorrect. So comments should be used with care.

### Comments Do Not Make Up for Bad Code

One of the more common motivations for writing comments is bad code. We write a mod ule and we know it is confusing and disorganized. We know it’s a mess. So we say to our selves, “Ooh, I’d better comment that!” No! You’d better clean it! Clear and expressive code with few comments is far superior to cluttered and complex code with lots of comments. Rather than spend your time writing the comments that explain the mess you’ve made, spend it cleaning that mess.

### Don't be redundant

Code that is

### Don't comment out code. Just remove.

Don't leave unsed code hanging around. We use git as a reason if one ever needs old code.

### Use as explanation of intent.

## Unit Tests

"The value of maintainable code is writting code so that when bugs happen (and they will happen) you can find them and you can fix them (and write test so they don't happen again"

### Why

Guard against changes in dependent packages Gain confidence of codebase Test after refactoring

1.  One assert per test.
2.  Readable.
3.  Fast.
4.  Independent.
5.  Repeatable.

## Code smells

1.  Rigidity. The software is difficult to change. A small change causes a cascade of subsequent changes.
2.  Fragility. The software breaks in many places due to a single change.
3.  Immobility. You cannot reuse parts of the code in other projects because of involved risks and high effort.
4.  Needless Complexity.
5.  Needless Repetition.
6.  Opacity. The code is hard to understand.

The question is if someone new can read the code
